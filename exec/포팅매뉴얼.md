# 포팅 매뉴얼

## 목차
[1. 개발 환경](#1-개발-환경) <br>
[2. 배포시 사용되는 환경변수](#2-배포시-사용되는-환경변수) <br>
[3. 배포 방법 [ Frontend + Backend ]](#3-배포-방법--frontend--backend-) <br>

## 1. 개발 환경

---

### Infra

- AWS EC2
- ubuntu 20.04
- JVM: OpenJDK 17
- ReverseProxy : Nginx 1.18.0
- WAS (Web Application Server): Tomcat

### Backend

- Java: `OpenJDK 17`
- Spring Boot: `3.3.3`
- Spring Dependency Management: `1.1.6`
- Build Tool: `Gradle`

### Frontend

- Typescript
- React: `18.3.1`
- tailwindcss: `3.4.14`
- vite: `5.4.8`

### Database

- MySQL : `9.1.0`
- MongoDB : `8.0.3`
- Radis : `5.0.7`

## 2. 배포시 사용되는 환경변수

### .env 파일
docker compose에 사용되는 환경변수 파일

```bash
# MongoDB 관련 환경 변수
MONGO_INITDB_ROOT_USERNAME={...} # ex) root
MONGO_INITDB_ROOT_PASSWORD={...} # ex) ssafy
MONGO_INITDB_DATABASE=sembot
MONGO_PORT=27017
MONGO_BINDING_PORT=27017

# MySQL 관련 환경 변수
MYSQL_DATABASE=chatbot
MYSQL_ROOT_PASSWORD={...} # ex) ssafy
MYSQL_USER={...} # ex) ssafy
MYSQL_PASSWORD={...} # ex) ssafy
MYSQL_PORT=3306
MYSQL_BINDING_PORT=3306

# Spring Boot Backend 관련 환경 변수
SPRING_DATA_REDIS_HOST={...} # ex) k11s102.p.ssafy.io 
REDIS_PORT=6379
CORS_ORIGIN_DEVELOPMENT=http://localhost:5173
CORS_ORIGIN_PRODUCTION={호스트 서버 도메인 명} # ex) k11s102.p.ssafy.io
FILE_UPLOAD_PATH={파일 저장 경로} # ex) /files
JWT_ACCESS_SECRET={JWT ACCESS SECRET KEY} # ex) qwejwsdfaodsfjdsofidsjqwejwsdfaodsfjdsoffoidsjkfdqwejwsdfaodsfjdsofidsjqwejwsdfaodsfjdsoffoidsjkfdhssdadfjdhssdadfjd
JWT_ACCESS_TOKEN_EXPIRATION={JWT ACCESS TOKEN 만료 기간 - ms} # ex) 7200000
JWT_REFRESH_SECRET={JWT REFRESH SECRET KEY}# ex) qwejwsdfaodsfjdsgfidsjqwejwsdfaodsfjdsoffoidsjkfdqwedwsdfaodsfjdsofidsjqwejwsddaodsfjdsoffoidsjkfdhssdadfjdhssdadwid
JWT_REFRESH_TOKEN_EXPIRATION={JWT REFRESH TOKEN 만료 기간 - ms} # ex) 1209600000

# Backend 포트 (Spring Boot 애플리케이션 포트)
BACKEND_PORT=8080
AI_BASE_URL={AI 서버 url} # ex) https://cba1-211-192-252-139.ngrok-free.app

FRONTEND_BINDING_PORT=3000
FRONTEND_PORT=80

VITE_BACKEND_URL={Backend 서버 url} # ex) https://sembot.co.kr
VITE_AI_URL={AI 서버 url} # ex) https://1242-35-226-42-109.ngrok-free.app
```

## 3. 배포 방법 [ Frontend + Backend ]

---

### **Docker 설치**

---

**1) 우분투 시스템 패키지 업데이트**

```bash
sudo apt-get update
```

**2) 필요한 패키지 설치**

```bash
sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common
```

**3) Docker의 공식 GPG키를 추가**

```bash
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
```

**4) Docker의 공식 apt 저장소를 추가**

```bash
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
```

**5) 시스템 패키지 업데이트**

```bash
sudo apt-get update
```

**6) Docker 설치**

```bash
sudo apt-get install docker-ce docker-ce-cli containerd.io
```

**7) Docker 설치 확인**

```bash
sudo systemctl status docker
```

### **git clone 후 서버 실행**

---

**1) git clone**

```bash
git clone https://lab.ssafy.com/s11-final/S11P31S102.git
```

**2) 폴더로 이동 후 [env파일](https://www.notion.so/698e11e49eaf4ad4b8e1e52684f07dae?pvs=21) 작성**

```bash
cd S11P31S102
vi .env
```

- 위에 있는 .env 내용 작성

**3) docker compose 실행**

```bash
docker compose up -d
```

### Nginx 설치 및 ssl 설정

---

**1) nginx 설치**

```bash
sudo apt install nginx
```

**2) http, https 방화벽 허용**

```bash
sudo ufw allow 'Nginx Full'
```

**3) Certbot 설치**

Certbot을 사용해 SSL 인증서를 발급받기 위해 Certbot 패키지를 설치합니다.

```bash
sudo apt-get update
sudo apt-get install python3-certbot-nginx
```

**4) Certbot 인증서 발급 과정 수행**

도메인 소유권 확인을 위해 SSL 인증서를 발급받습니다.

```bash
sudo certbot certonly --nginx -d {도메인명 or ip}
```

- 도메인 또는 IP를 입력합니다.

**5) nginx config 파일 생성 및 Nginx 설정 확인**

- /etc/nginx/sites-available/default

```bash
server {
        listen 80;
        listen [::]:80;
        server_name {도메인명 or ip};
        return 301 https://$host$request_uri;
}
server {
    server_name {도메인명 or ip}; # managed by Certbot

    # /api 경로는 Spring Boot로 프록시
    location /api/ {
        proxy_pass http://localhost:8080/api/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # /api/notifications/subscribe/ 경로는 buffer 사용 x - SSE 사용을 위함
    location /api/notifications/subscribe/ {
        proxy_pass http://localhost:8080/api/notifications/subscribe/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header X-Accel-Buffering no;
        proxy_buffering off;
        proxy_cache off;
        proxy_read_timeout 3600s;  # 1시간
        proxy_send_timeout 3600s;  # 1시간
    }

    # 그 외 모든 요청은 frontend로 프록시
    location / {
        proxy_pass http://localhost:3000/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

		# 이 아래는 위에서 certbot ... 명령어 실행시 자동으로 생성될 것
    listen [::]:443 ssl ipv6only=on; # managed by Certbot
    listen 443 ssl; # managed by Certbot
    ssl_certificate /etc/letsencrypt/live/{도메인명 or ip}/fullchain.pem; # managed by Certbot
    ssl_certificate_key /etc/letsencrypt/live/{도메인명 or ip}/privkey.pem; # managed by Certbot
    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot
}
server {
    if ($host = {도메인명 or ip}) {
        return 301 https://$host$request_uri;
    } # managed by Certbot

    listen 80 ;
    listen [::]:80 ;
    server_name {도메인명 or ip};
    return 404; # managed by Certbot
}

```

**6) Nginx 재시작**

도전 파일 설정이 완료되면 Nginx를 재시작하여 설정을 반영합니다.

```bash
sudo nginx -t
sudo systemctl reload nginx
```